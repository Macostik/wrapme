//
//  WrapPickerViewController.swift
//  meWrap
//
//  Created by Sergey Maximenko on 1/30/16.
//  Copyright Â© 2016 Ravenpod. All rights reserved.
//

import UIKit

class WrapPickerDataSource: StreamDataSource {
    
    var didEndScrollingAnimationBlock: (Void -> Void)?
    
    func scrollViewWillEndDragging(scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
        targetContentOffset.memory.y = round(targetContentOffset.memory.y / autogeneratedMetrics.size) * autogeneratedMetrics.size
    }
    
    func scrollViewDidEndScrollingAnimation(scrollView: UIScrollView) {
        if let block = didEndScrollingAnimationBlock {
            block()
            didEndScrollingAnimationBlock = nil
        }
    }
}

protocol WrapPickerViewControllerDelegate: class {
    func wrapPickerViewController(controller: WrapPickerViewController, didCreateWrap wrap: Wrap)
    func wrapPickerViewController(controller: WrapPickerViewController, didSelectWrap wrap: Wrap)
    func wrapPickerViewControllerDidFinish(controller: WrapPickerViewController)
    func wrapPickerViewControllerDidCancel(controller: WrapPickerViewController)
}

private let ItemHeight: CGFloat = 55

class WrapPickerViewController: WLBaseViewController {

    weak var delegate: WrapPickerViewControllerDelegate?
    
    weak var wrap: Wrap?
    
    @IBOutlet weak var streamView: StreamView!
    
    lazy var dataSource: WrapPickerDataSource = WrapPickerDataSource(streamView: self.streamView)
    
    @IBOutlet weak var wrapNameTextField: UITextField!
    
    @IBOutlet var editingPrioritizer: LayoutPrioritizer!
    
    private var wraps: [Wrap]? {
        didSet {
            dataSource.items = wraps
        }
    }
    
    deinit {
        streamView.removeObserver(self, forKeyPath: "contentOffset", context: nil)
    }
    
    override func prefersStatusBarHidden() -> Bool {
        return true
    }
    
    override func preferredStatusBarUpdateAnimation() -> UIStatusBarAnimation {
        return .Slide
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        dataSource.layoutOffset = ItemHeight
        dataSource.itemSize = ItemHeight
        streamView.contentInset = UIEdgeInsetsMake(ItemHeight, 0, ItemHeight, 0)
        streamView.scrollIndicatorInsets = streamView.contentInset
        
        dataSource.autogeneratedMetrics.identifier = "WrapPickerCell"
        dataSource.autogeneratedMetrics.selection = { [unowned self] item, entry in
            if let index = item?.position.index where self.streamView.contentOffset.y != CGFloat(index) * CGFloat(ItemHeight) {
                self.streamView.setContentOffset(CGPoint(x: 0, y: CGFloat(index) * CGFloat(ItemHeight)), animated: true)
            } else {
                Dispatch.mainQueue.async {
                    self.delegate?.wrapPickerViewControllerDidFinish(self)
                }
            }
        }
        
        wraps = User.currentUser?.sortedWraps
        
        if let wrap = wrap, let index = wraps?.indexOf(wrap) {
            streamView.setContentOffset(CGPoint(x: 0, y: CGFloat(index) * CGFloat(ItemHeight)), animated: true)
        }
        
        view.addGestureRecognizer(streamView.panGestureRecognizer)
        streamView.addObserver(self, forKeyPath: "contentOffset", options: .New, context: nil)
        
        wrapNameTextField.placeholder = "new_wrap".ls
        if wrap == nil {
            editingPrioritizer.defaultState = true
            Dispatch.mainQueue.async { self.wrapNameTextField.becomeFirstResponder() }
        }
        Wrap.notifier().addReceiver(self)
    }
    
    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer<Void>) {
        let offset = streamView.contentOffset.y
        if wraps?.count > 0 && offset >= 0 {
            let index = Int(round(offset / ItemHeight))
            if let wrap = wraps?[safe: index] where wrap != self.wrap {
                self.wrap = wrap
                delegate?.wrapPickerViewController(self, didSelectWrap: wrap)
            }
        }
    }
    
    override func constantForKeyboardAdjustmentBottomConstraint(constraint: NSLayoutConstraint!, defaultConstant: CGFloat, keyboardHeight: CGFloat) -> CGFloat {
        return max(0, keyboardHeight - (view.height - streamView.frame.maxY - 10))
    }
    
    func showInViewController(controller: UIViewController) {
        controller.addContainedViewController(self, animated: false)
    }
    
    func hide() {
        view.endEditing(true)
        removeFromContainerAnimated(false)
    }
}

extension WrapPickerViewController: EntryNotifying {
    
    func notifier(notifier: EntryNotifier, didAddEntry entry: Entry) {
        wraps = User.currentUser?.sortedWraps
    }
    
    func notifier(notifier: EntryNotifier, didUpdateEntry entry: Entry, event: EntryUpdateEvent) {
        wraps = User.currentUser?.sortedWraps
    }
    
    func notifier(notifier: EntryNotifier, willDeleteEntry entry: Entry) {
        if let wrap = entry as? Wrap {
            wraps = wraps?.filter({ $0 != wrap })
        }
    }
}

extension WrapPickerViewController {
    
    @IBAction func createNewWrap(sender: AnyObject?) {
        wrapNameTextField.becomeFirstResponder()
    }
    
    @IBAction func saveNewWrap(sender: WLButton) {
        
        guard let name = wrapNameTextField.text?.trim where name.isEmpty == false else {
            Toast.show("wrap_name_cannot_be_blank".ls)
            return
        }
        
        wrapNameTextField.resignFirstResponder()
        
        let wrap = Wrap.wrap()
        wrap.name = name
        wrap.notifyOnAddition()
        delegate?.wrapPickerViewController(self, didSelectWrap:wrap)
        delegate?.wrapPickerViewController(self, didCreateWrap:wrap)
        delegate?.wrapPickerViewControllerDidFinish(self)
        Uploader.wrapUploader.upload(Uploading.uploading(wrap), success: nil) { (error) -> Void in
            if let error = error where !error.isNetworkError {
                error.show()
                wrap.remove()
            }
        }
    }
    
    @IBAction func hide(sender: AnyObject?) {
        if wrapNameTextField.isFirstResponder() {
            wrapNameTextField.resignFirstResponder()
        } else {
            delegate?.wrapPickerViewControllerDidCancel(self)
        }
    }
}

extension WrapPickerViewController: UITextFieldDelegate {
    
    @IBAction func textFieldDidChange(textField: UITextField) {
        let text = textField.text ?? ""
        if text.characters.count > Constants.profileNameLimit {
            textField.text = text.substringToIndex(text.startIndex.advancedBy(Constants.profileNameLimit))
        }
    }
    
    func textFieldDidBeginEditing(textField: UITextField) {
        wrapNameTextField.placeholder = "what_is_new_wrap_about".ls
        editingPrioritizer.setDefaultState(false, animated: true)
    }
    
    func textFieldDidEndEditing(textField: UITextField) {
        wrapNameTextField.placeholder = "new_wrap".ls
        editingPrioritizer.setDefaultState(true, animated: true)
    }
    
    func textFieldShouldBeginEditing(textField: UITextField) -> Bool {
        let shouldBeginEditing = streamView.contentOffset.y == -ItemHeight
        if !shouldBeginEditing {
            dataSource.didEndScrollingAnimationBlock = { [weak textField] _ in
                textField?.becomeFirstResponder()
            }
            streamView.setContentOffset(CGPoint(x: 0, y: -ItemHeight), animated: true)
        }
        return shouldBeginEditing
    }
    
    func textFieldShouldReturn(textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }
}
