//
//  ContributorsViewController.swift
//  meWrap
//
//  Created by Sergey Maximenko on 2/10/16.
//  Copyright Â© 2016 Ravenpod. All rights reserved.
//

import UIKit

private let VerticalIndent: CGFloat = 48.0
private let HorizontalIndent: CGFloat = 96.0
private let MinHeight: CGFloat = 72.0

final class ContributorsViewController: BaseViewController {
    
    weak var wrap: Wrap?
    
    @IBOutlet weak var streamView: StreamView!
    
    private lazy var dataSource: StreamDataSource = StreamDataSource(streamView: self.streamView)
    
    @IBOutlet weak var addFriendView: UIView!
    
    @IBOutlet var restrictedInvitePrioritizer: LayoutPrioritizer!
    
    private var invitedContributors = Set<User>()
    
    private var removedContributors = Set<User>()
    
    private weak var contributiorWithOpenedMenu: User?
    
    private var contributors: [User] = [] {
        didSet {
            if contributors != oldValue {
                dataSource.items = contributors
            }
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        dataSource.autogeneratedMetrics.identifier = "ContributorCell"
        dataSource.autogeneratedMetrics.modifyItem = { item in
            let font = UIFont.fontSmall()
            let textWidth = Constants.screenWidth - HorizontalIndent
            let contributor = item.entry as! User
            let pandingHeight = contributor.isInvited ? "sign_up_pending".ls.heightWithFont(font, width:textWidth) : 0
            var phoneHeight = contributor.securePhones != nil ? contributor.securePhones!.heightWithFont(font, width:textWidth) : 0
            let invitationText = ContributorCell.invitationHintText(contributor)
            phoneHeight += invitationText.heightWithFont(font, width:textWidth)
            item.size = max(phoneHeight + pandingHeight + VerticalIndent, MinHeight) + 1
        }
        
        dataSource.autogeneratedMetrics.prepareAppearing = { [weak self] item, view in
            (view as? ContributorCell)?.delegate = self
        }
        
        streamView.contentInset = UIEdgeInsetsMake(0, 0, 44, 0)
        streamView.scrollIndicatorInsets = streamView.contentInset
        
        Wrap.notifier().addReceiver(self)
        
        updateContributors()
        
        if let wrap = wrap {
            APIRequest.contributors(wrap).send({ [weak self] _ in
                self?.updateContributors()
                }) { [weak self] (error) -> Void in
                    self?.dataSource.reload()
                    error?.showNonNetworkError()
            }
        }
    }
    
    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)
        if let wrap = wrap, let contributor = wrap.contributor where !contributor.current {
            restrictedInvitePrioritizer.defaultState = !wrap.isRestrictedInvite
        }
    }
    
    private func updateContributors() {
        contributors = wrap?.contributors.subtract(removedContributors).sort {
            if $0.current {
                return false
            } else if $1.current {
                return true
            } else {
                return $0.name < $1.name
            }
            } ?? []
    }
}

extension ContributorsViewController: ContributorCellDelegate {
    
    func contributorCell(cell: ContributorCell, didRemoveContributor contributor: User) {
        
        guard let wrap = wrap else { return }
        
        if let index = contributors.indexOf(contributor) {
            contributors.removeAtIndex(index)
        }
        
        removedContributors.insert(contributor)
        
        APIRequest.removeContributors([contributor], wrap: wrap)?.send({ [weak self] (_) -> Void in
            self?.removedContributors.remove(contributor)
            if self?.contributiorWithOpenedMenu == contributor {
                self?.contributiorWithOpenedMenu = nil
            }
            }, failure: { [weak self] (error) -> Void in
                error?.show()
                self?.removedContributors.remove(contributor)
                self?.updateContributors()
            })
    }
    
    private func hideMenuForContributor(contributor: User) {
        if contributiorWithOpenedMenu == contributor {
            contributiorWithOpenedMenu = nil
            for item in streamView.visibleItems() {
                if let cell = item.view as? ContributorCell where cell.entry === contributor {
                    cell.setMenuHidden(true, animated: true)
                    break
                }
            }
        }
    }
    
    func contributorCell(cell: ContributorCell, didInviteContributor contributor: User, completionHandler: Bool -> Void) {
        
        guard let wrap = wrap else { return }
        
        APIRequest.resendInvite(wrap, user: contributor).send({ [weak self] (_) -> Void in
            completionHandler(true)
            self?.invitedContributors.insert(contributor)
            self?.enqueueSelector("hideMenuForContributor:", argument: contributor, delay: 3.0)
            }) { (error) -> Void in
                error?.show()
                completionHandler(false)
        }
    }
    
    func contributorCell(cell: ContributorCell, isInvitedContributor contributor: User) -> Bool {
        return invitedContributors.contains(contributor)
    }
    
    func contributorCell(cell: ContributorCell, isCreator contributor: User) -> Bool {
        return wrap?.contributor == contributor
    }
    
    func contributorCell(cell: ContributorCell, didToggleMenu contributor: User) {
        if let contributor = contributiorWithOpenedMenu {
            NSObject.cancelPreviousPerformRequestsWithTarget(self, selector:"hideMenuForContributor:", object:contributor)
        }
        
        if contributiorWithOpenedMenu == contributor {
            contributiorWithOpenedMenu = nil
        } else {
            contributiorWithOpenedMenu = contributor
            for item in streamView.visibleItems() {
                if let cell = item.view as? ContributorCell where cell.entry !== contributor {
                    cell.setMenuHidden(true, animated: true)
                }
            }
        }
    }
    
    func contributorCell(cell: ContributorCell, showMenu contributor: User) -> Bool {
        return contributiorWithOpenedMenu == contributor
    }
}

extension ContributorsViewController: EntryNotifying {
    
    func notifier(notifier: EntryNotifier, shouldNotifyOnEntry entry: Entry) -> Bool {
        return wrap == entry
    }
    
    func notifier(notifier: EntryNotifier, didUpdateEntry entry: Entry, event: EntryUpdateEvent) {
        if event == .ContributorsChanged {
            updateContributors()
            if let wrap = wrap, let contributor = wrap.contributor where !contributor.current {
                restrictedInvitePrioritizer.setDefaultState(!wrap.isRestrictedInvite, animated: viewAppeared)
            }
        }
    }
}
