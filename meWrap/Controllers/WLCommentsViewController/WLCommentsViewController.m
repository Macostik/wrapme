//
//  WLCommentsViewController.m
//  
//
//  Created by Yura Granchenko on 28/01/15.
//
//

#import "WLCommentsViewController.h"
#import "WLCandyViewController.h"

static CGFloat WLNotificationCommentHorizontalSpacing = 84.0f;
static CGFloat WLNotificationCommentVerticalSpacing = 24.0f;

@interface WLCommentsViewController () <UIViewControllerTransitioningDelegate, UIScrollViewDelegate, EntryNotifying>

@property (strong, nonatomic) IBOutlet StreamDataSource *dataSource;
@property (weak, nonatomic) IBOutlet LayoutPrioritizer *composeBarBottomPrioritizer;
@property (weak, nonatomic) IBOutlet InternalScrollView *contentView;
@property (weak, nonatomic) HistoryViewController *historyViewController;

@property (strong, nonatomic) EntryNotifyReceiver *candyNotifyReceiver;

@property (strong, nonatomic) EntryNotifyReceiver *commentNotifyReceiver;

@end

@implementation WLCommentsViewController

- (void)dealloc {
    self.contentView.delegate = nil;
}

- (void)viewDidLoad {
    
    __weak typeof(self)weakSelf = self;
    
    __weak StreamView *streamView = self.dataSource.streamView;
    
    [super viewDidLoad];
    
    if  (!self.candy.valid) return;
    
    for (Comment *comment in self.candy.comments) {
        [comment markAsUnread:NO];
    }
    
    self.dataSource.autogeneratedMetrics.selectable = NO;
    [self.dataSource.autogeneratedMetrics setSizeAt:^CGFloat(StreamItem *item) {
        Comment *comment = item.entry;
        UIFont *font = [UIFont fontNormal];
        UIFont *nameFont = [UIFont lightFontNormal];
        UIFont *timeFont = [UIFont lightFontSmall];
        CGFloat textHeight = [comment.text heightWithFont:font width:streamView.width - WLNotificationCommentHorizontalSpacing];
        return MAX(72, textHeight + nameFont.lineHeight + timeFont.lineHeight + WLNotificationCommentVerticalSpacing);
    }];
 
    [self.dataSource setDidLayoutBlock:^{
        [weakSelf.dataSource.streamView setMaximumContentOffsetAnimated:NO];
    }];
    
    self.dataSource.items = [self.candy sortedComments];
    [[Dispatch mainQueue] async:^{
        weakSelf.dataSource.didLayoutBlock = nil;
    }];
    
    if (self.candy.uploaded) {
        [self.candy fetch:^(id object) {
            weakSelf.dataSource.items = [weakSelf.candy sortedComments];
        } failure:^(NSError *error) {
            [weakSelf.dataSource reload];
            [error showNonNetworkError];
        }];
    }
    
    [self addNotifyReceivers];
    [[DeviceManager defaultManager] addReceiver:self];
    self.historyViewController = (HistoryViewController *)self.parentViewController;
}

- (void)requestAuthorizationForPresentingEntry:(Entry *)entry completion:(BooleanBlock)completion {
    completion(![self.candy.comments containsObject:(id)entry]);
}

- (void)sendMessageWithText:(NSString*)text {
    if (self.candy.valid) {
        [[SoundPlayer player] play:Sounds04];
        [self.candy uploadComment:[text trim]];
    }
    [[Dispatch mainQueue] after:0 block:^{
        [self onClose:nil];
    }];
}

- (IBAction)onClose:(id)sender {
    [self.view endEditing:YES];
    [self.view removeFromSuperview];
    [self.historyViewController viewWillAppear:YES];
    [self removeFromContainerAnimated:YES];
    [self.historyViewController applyScaleToCandyViewController:NO];
}

- (IBAction)hide:(UITapGestureRecognizer *)sender {
    UIView *contentView = self.dataSource.streamView.superview;
    CGPoint touchPoint = [sender locationInView:contentView];
    if (CGRectContainsPoint(contentView.bounds, touchPoint)) {
        [self.view endEditing:YES];
    } else {
        [self onClose:nil];
    }
}

#pragma mark - EntryNotifying

- (void)addNotifyReceivers {
    __weak typeof(self)weakSelf = self;
    
    self.commentNotifyReceiver = [[Comment notifyReceiver] setup:^(EntryNotifyReceiver *receiver) {
        [receiver setShouldNotify:^BOOL(Entry *entry) {
            Comment *comment = (Comment *)entry;
            NSArray *comments = (NSArray*)weakSelf.dataSource.items;
            return comment.candy == weakSelf.candy || [comments containsObject:comment];
        }];
        receiver.willDelete = ^(Entry *entry) {
            NSMutableArray *comments = [NSMutableArray arrayWithArray:(NSArray*)weakSelf.dataSource.items];
            [comments removeObject:entry];
            weakSelf.dataSource.items = [comments copy];
        };
        receiver.didAdd = ^(Entry *entry) {
            weakSelf.dataSource.items = [weakSelf.candy sortedComments];
        };
        receiver.didUpdate = ^(Entry *entry, EntryUpdateEvent event) {
            weakSelf.dataSource.items = [weakSelf.candy sortedComments];
        };
    }];
    
    self.candyNotifyReceiver = [[Candy notifyReceiver] setup:^(EntryNotifyReceiver *receiver) {
        [receiver setEntry:^Entry *{
            return weakSelf.candy;
        }];
        [receiver setContainer:^Entry *{
            return weakSelf.candy.wrap;
        }];
        receiver.willDeleteContainer = receiver.willDelete = ^(Entry *entry) {
            [weakSelf onClose:nil];
        };
    }];
}

#pragma mark - ComposeBarDelegate

- (void)composeBar:(ComposeBar *)composeBar didFinishWithText:(NSString *)text {
    [self sendMessageWithText:text];
}

- (BOOL)composeBarDidShouldResignOnFinish:(ComposeBar *)composeBar {
    return NO;
}

#pragma mark - KeyboardNotifying

static CGFloat WLContstraintOffset = 44.0;

- (CGFloat)keyboardAdjustmentForConstraint:(NSLayoutConstraint *)constraint defaultConstant:(CGFloat)defaultConstant keyboardHeight:(CGFloat)keyboardHeight {
    return keyboardHeight - WLContstraintOffset;
}

#pragma mark - DeviceManager

- (void)manager:(DeviceManager *)manager didChangeOrientation:(UIDeviceOrientation)orientation {
    [self.view layoutIfNeeded];
    [self.dataSource reload];
}

// MARK: - UIScrollViewDelegate

- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    BOOL direction = [scrollView.panGestureRecognizer translationInView:scrollView.superview].y < 0;
    self.composeBarBottomPrioritizer.defaultState = direction;
}

- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset {
    CGPoint offset = scrollView.contentOffset;
    if (ABS(offset.y) > scrollView.height/5 || ABS(velocity.y) > 2) {
        UIView *snapshot = [self.contentView snapshotViewAfterScreenUpdates:NO];
        snapshot.frame = CGRectMake(0, self.contentView.y, self.view.width, self.contentView.height);
        [self.view.window addSubview:snapshot];
        [self removeFromContainerAnimated:YES];
        [UIView animateWithDuration:0.5 animations:^{
            CGFloat offsetY = offset.y > 0 ? self.view.y - self.view.height : self.view.height;
            snapshot.transform = CGAffineTransformMakeTranslation(0, offsetY);
            [self.historyViewController applyScaleToCandyViewController:NO];
        } completion:^(BOOL finished) {
            [snapshot removeFromSuperview];
        }];
    } 
}

- (void)presentForController:(UIViewController *)controller animated:(BOOL)animated {
    [controller addContainedViewController:self animated:animated];
    self.contentView.transform = CGAffineTransformMakeTranslation(0, CGRectGetMaxY(self.view.frame));
    [UIView animateWithDuration:0.5f
                          delay:0.0f
         usingSpringWithDamping:0.7f
          initialSpringVelocity:1
                        options:UIViewAnimationOptionCurveEaseIn
                     animations:^{
        self.contentView.transform = CGAffineTransformIdentity;
    }               completion:nil];
}

@end
