//
//  WLEditassetsViewController.m
//  meWrap
//
//  Created by Ravenpod on 6/11/15.
//  Copyright (c) 2015 Ravenpod. All rights reserved.
//

#import "WLBatchEditPictureViewController.h"
#import "WLComposeBar.h"
#import "WLImageEditorSession.h"
#import "WLToast.h"
#import "WLHintView.h"
#import "WLDrawingViewController.h"

static const int WLInstanceCommentLimit = 1500;

@interface WLBatchEditPictureViewController () <WLComposeBarDelegate, VideoPlayerViewDelegate>

@property (strong, nonatomic) IBOutlet StreamDataSource *dataSource;

@property (weak, nonatomic) MutableAsset *asset;

@property (weak, nonatomic) IBOutlet WLComposeBar *composeBar;
@property (weak, nonatomic) IBOutlet UIView *bottomView;
@property (weak, nonatomic) IBOutlet UIButton *deleteButton;
@property (weak, nonatomic) IBOutlet UIButton *editButton;
@property (weak, nonatomic) IBOutlet UIButton *restoreButton;
@property (weak, nonatomic) IBOutlet UIButton *uploadButton;
@property (weak, nonatomic) IBOutlet NSLayoutConstraint *uploadButtonXConstraint;
@property (weak, nonatomic) IBOutlet UIButton *drawButton;
@property (weak, nonatomic) IBOutlet VideoPlayerView *videoPlayerView;

@end

@implementation WLBatchEditPictureViewController

@synthesize wrap = _wrap;

@synthesize delegate = _delegate;

@synthesize wrapView = _wrapView;

@synthesize mode = _mode;

- (void)dealloc {
    [self.dataSource.streamView removeObserver:self forKeyPath:@"contentOffset" context:NULL];
    [self.dataSource.streamView removeObserver:self forKeyPath:@"contentSize" context:NULL];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self.view addGestureRecognizer:self.scrollView.panGestureRecognizer];
    
    self.videoPlayerView.delegate = self;
    
    __weak StreamDataSource *dataSource = self.dataSource;
    __weak StreamView *streamView = dataSource.streamView;
    
    dataSource.autogeneratedMetrics.size = MIN(80, streamView.height - 30);
    
    streamView.contentInset = streamView.scrollIndicatorInsets = UIEdgeInsetsMake(0, 0, 0, 60);
    
    [streamView addObserver:self forKeyPath:@"contentOffset" options:NSKeyValueObservingOptionNew context:NULL];
    [streamView addObserver:self forKeyPath:@"contentSize" options:NSKeyValueObservingOptionNew context:NULL];
    
    [streamView.superview addGestureRecognizer:streamView.panGestureRecognizer];
    
    [self setupWrapView:self.wrap];
    [self setViewController:[self editPictureViewControllerForPicture:self.assets.firstObject] direction:0 animated:NO];
    
    __weak typeof(self)weakSelf = self;
    [dataSource.autogeneratedMetrics setSelection:^(StreamItem *item, MutableAsset *asset) {
        if (weakSelf.asset != asset) {
            [weakSelf setViewController:[weakSelf editPictureViewControllerForPicture:asset] direction:0 animated:NO];
        }
    }];
}

- (void)viewDidAppear:(BOOL)animated {
    [super viewDidAppear:animated];
    self.dataSource.items = self.assets;
    self.uploadButton.active = YES;
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    [self updateUploadButtonPosition];
}

- (void)updateUploadButtonPosition {
    StreamView *streamView = self.dataSource.streamView;
    CGFloat constant = (streamView.contentOffset.x - streamView.maximumContentOffset.x) + 30;
    if (self.uploadButtonXConstraint.constant != constant) {
        self.uploadButtonXConstraint.constant = constant;
        [self.uploadButton setNeedsLayout];
    }
}

- (void)setAsset:(MutableAsset *)asset {
    _asset = asset;
    [self updatePictureData:asset];
}

- (void)updatePictureData:(MutableAsset *)asset {
    if (asset.deleted) {
        self.drawButton.hidden = self.deleteButton.hidden = self.editButton.hidden = self.composeBar.hidden = YES;
        self.restoreButton.hidden = NO;
        if (self.composeBar.isFirstResponder) {
            [self.composeBar resignFirstResponder];
        }
        self.videoPlayerView.url = nil;
        self.videoPlayerView.hidden = YES;
    } else {
        self.deleteButton.hidden = self.composeBar.hidden = NO;
        self.drawButton.hidden = self.editButton.hidden = asset.type == MediaTypeVideo;
        self.restoreButton.hidden = YES;
        self.composeBar.text = asset.comment;
        if (asset.type == MediaTypeVideo) {
            self.videoPlayerView.url = [asset.original fileURL];
            self.videoPlayerView.hidden = NO;
        } else {
            self.videoPlayerView.url = nil;
            self.videoPlayerView.hidden = YES;
        }
    }
    for (MutableAsset *asset in self.assets) {
        asset.selected = asset == self.asset;
    }
    [self.dataSource reload];
    StreamItem *item = [self.dataSource.streamView itemPassingTest:^BOOL(StreamItem *item) {
        return item.entry == self.asset;
    }];
    [self.dataSource.streamView scrollToItem:item animated:YES];
}

// MARK: - WLStillPictureBaseViewController

- (void)setWrap:(Wrap *)wrap {
    _wrap = wrap;
    if (self.isViewLoaded) {
        [self setupWrapView:wrap];
    }
}

- (void)setupWrapView:(Wrap *)wrap {
    if (self.wrapView) {
        self.wrapView.entry = wrap;
        self.wrapView.hidden = wrap == nil;
    }
}

- (void)stillPictureViewController:(WLStillPictureBaseViewController *)controller didSelectWrap:(Wrap *)wrap {
    [self selectWrap:nil];
}

- (IBAction)selectWrap:(UIButton *)sender {
    if (self.delegate) {
        if ([self.delegate respondsToSelector:@selector(stillPictureViewController:didSelectWrap:)]) {
            [self.delegate stillPictureViewController:self didSelectWrap:self.wrap];
        }
    } else if (self.presentingViewController) {
        [self.presentingViewController dismissViewControllerAnimated:NO completion:nil];
    }
}

- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    return UIInterfaceOrientationMaskPortrait;
}

- (BOOL)prefersStatusBarHidden {
    return YES;
}

- (UIStatusBarAnimation)preferredStatusBarUpdateAnimation {
    return UIStatusBarAnimationSlide;
}

- (EditAssetViewController *)editPictureViewControllerForPicture:(MutableAsset *)asset {
    EditAssetViewController *controller = self.storyboard[@"editAsset"];
    controller.asset = asset;
    return controller;
}

// MARK: - WLSwipeViewController

- (UIViewController *)viewControllerAfterViewController:(EditAssetViewController *)viewController {
    MutableAsset *picture = [self.assets tryAt:[self.assets indexOfObject:viewController.asset] + 1];
    if (picture) {
        return [self editPictureViewControllerForPicture:picture];
    }
    return nil;
}

- (UIViewController *)viewControllerBeforeViewController:(EditAssetViewController *)viewController {
    MutableAsset *picture = [self.assets tryAt:[self.assets indexOfObject:viewController.asset] - 1];
    if (picture) {
        return [self editPictureViewControllerForPicture:picture];
    }
    return nil;
}

- (void)didChangeViewController:(EditAssetViewController *)viewController {
    self.asset = viewController.asset;
}

// MARK: - Actions

- (void)back:(UIButton *)sender {
    if ([[UIDevice currentDevice] systemVersionSince:@"9"]) {
        [self.navigationController popViewControllerAnimated:YES];
    } else {
        [self.navigationController popViewControllerAnimated:NO];
    }
}

- (IBAction)upload:(id)sender {
    self.asset.comment = self.composeBar.text;
    NSMutableArray *assets = [NSMutableArray arrayWithCapacity:self.assets.count];
    for (MutableAsset *picture in self.assets) {
        if (!picture.deleted) {
            [assets addObject:picture];
        }
    }
    if (assets.nonempty) {
        [self.delegate batchEditPictureViewController:self didFinishWithAssets:assets];
    } else {
        [WLToast showWithMessage:@"no_photos_to_upload".ls];
    }
}

- (IBAction)edit:(id)sender {
    __weak typeof(self)weakSelf = self;
    UIImage *image = [(EditAssetViewController*)self.viewController imageView].image;
    if (!image) {
        return;
    }
    UIViewController* controller = [WLImageEditorSession editControllerWithImage:image completion:^(UIImage *image) {
        [weakSelf editCurrentPictureWithImage:image];
        [weakSelf.navigationController popViewControllerAnimated:NO];
    } cancel:^ {
        [weakSelf.navigationController popViewControllerAnimated:NO];
    }];
    [self.navigationController pushViewController:controller animated:NO];
}

- (void)editCurrentPictureWithImage:(UIImage*)image {
    __weak typeof(self)weakSelf = self;
    self.uploadButton.active = NO;
    [self.asset setImage:image completion:^(id object) {
        weakSelf.asset.edited = YES;
        [weakSelf.dataSource reload];
        weakSelf.uploadButton.active = YES;
    }];
    [(EditAssetViewController*)self.viewController imageView].image = image;
}

- (IBAction)deletePicture:(id)sender {
    self.asset.deleted = YES;
    [(EditAssetViewController*)self.viewController updateDeletionState];
    [self updatePictureData:self.asset];
}

- (IBAction)restoreDeletedPicture:(id)sender {
    self.asset.deleted = NO;
    [(EditAssetViewController*)self.viewController updateDeletionState];
    [self updatePictureData:self.asset];
}

- (IBAction)draw:(id)sender {
    [self.composeBar resignFirstResponder];
    UIImage *image = [(EditAssetViewController*)self.viewController imageView].image;
    if (image) {
        __weak typeof(self)weakSelf = self;
        WLDrawingViewController *drawingViewController = [[WLDrawingViewController alloc] init];
        drawingViewController.bottomViewHeightConstraint.constant = self.bottomView.height;
        [drawingViewController setImage:image done:^(UIImage *image) {
            [weakSelf editCurrentPictureWithImage:image];
            [weakSelf dismissViewControllerAnimated:NO completion:nil];
        } cancel:^{
            [weakSelf dismissViewControllerAnimated:NO completion:nil];
        }];
        [weakSelf presentViewController:drawingViewController animated:NO completion:nil];
    }
}

// MARK: - WLComposeBarDelegate

- (IBAction)composeBarDidFinish:(id)sender {
    [self.composeBar resignFirstResponder];
    [self.composeBar setDoneButtonHidden:YES];
}

- (void)composeBarDidChangeText:(WLComposeBar *)composeBar {
    NSString *comment = composeBar.text;
    while ([self commentLimitExceeded:comment]) {
        comment = [comment substringToIndex:comment.length - 1];
    }
    if (![comment isEqualToString:composeBar.text]) {
        [WLToast showWithMessage:@"comment_limit".ls];
        composeBar.text = comment;
    }
    self.asset.comment = comment;
    __weak typeof(self)weakSelf = self;
    StreamItem *item = [self.dataSource.streamView itemPassingTest:^BOOL(StreamItem *item) {
        return item.entry == weakSelf.asset;
    }];
    [(EditAssetCell*)item.view updateStatus];
}

- (BOOL)commentLimitExceeded:(NSString*)text {
    if (text.length <= WLInstanceCommentLimit) {
        return NO;
    } else {
        return [text dataUsingEncoding:NSUTF8StringEncoding].length > WLInstanceCommentLimit;
    }
}

- (void)composeBarDidEndEditing:(WLComposeBar *)composeBar {
    self.asset.comment = composeBar.text;
    self.scrollView.userInteractionEnabled = YES;
}

- (void)composeBarDidBeginEditing:(WLComposeBar *)composeBar {
    self.scrollView.userInteractionEnabled = NO;
}

- (CGFloat)constantForKeyboardAdjustmentBottomConstraint:(NSLayoutConstraint *)constraint defaultConstant:(CGFloat)defaultConstant keyboardHeight:(CGFloat)keyboardHeight {
    return (keyboardHeight - self.bottomView.height);
}

// MARK: - VideoPlayerViewDelegate

- (void)videoPlayerViewDidPlay:(VideoPlayerView *)view {
    self.scrollView.panGestureRecognizer.enabled = NO;
}

- (void)videoPlayerViewDidPause:(VideoPlayerView *)view {
    self.scrollView.panGestureRecognizer.enabled = YES;
}

@end
