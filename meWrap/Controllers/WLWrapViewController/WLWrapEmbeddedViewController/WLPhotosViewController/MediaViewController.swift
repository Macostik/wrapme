//
//  MediaViewController.swift
//  meWrap
//
//  Created by Sergey Maximenko on 12/8/15.
//  Copyright Â© 2015 Ravenpod. All rights reserved.
//

import UIKit

class HistoryDateSeparator: StreamReusableView {
    
    @IBOutlet weak var dateLabel: UILabel!
    
    override func setup(entry: AnyObject!) {
        if let item = entry as? HistoryItem {
            dateLabel.text = item.date.stringWithDateStyle(.MediumStyle)
        }
    }
}

class HistoryItemCell: StreamReusableView {
    
    class HistoryItemDataSource: StreamDataSource {
        func scrollViewWillEndDragging(scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
            let x = targetContentOffset.memory.x
            let maxX = scrollView.maximumContentOffset.x
            if abs(x - maxX) <= 1 || abs(x) <= 1 {
                return
            }
            let point = CGPoint(x: x, y: scrollView.frame.midY)
            if var item = streamView?.itemPassingTest({ $0.frame.contains(point) }) {
                if (x - item.frame.origin.x) > item.frame.size.width/2 {
                    if let next = item.next {
                        item = next
                    }
                }
                targetContentOffset.memory.x = item.frame.origin.x
            }
        }
    }
    
    @IBOutlet weak var streamView: StreamView!
    
    private var dataSource: HistoryItemDataSource!
    
    internal override func willEnqueue() {
        super.willEnqueue()
        (entry as? HistoryItem)?.offset = streamView.contentOffset
    }
    
    override func loadedWithMetrics(metrics: StreamMetrics!) {
        streamView.layout = SquareLayout(horizontal: true)
        dataSource = HistoryItemDataSource(streamView: streamView)
        dataSource.addMetrics(StreamMetrics(identifier: "CandyCell")).selection = metrics.selection
        dataSource.layoutSpacing = Constants.pixelSize
    }
    
    override func setup(entry: AnyObject!) {
        streamView.frame = bounds
        if let item = entry as? HistoryItem {
            dataSource.items = item.candies
            streamView.contentOffset = item.offset
        }
    }
}

class LiveBroadcastMediaView: StreamReusableView {
    
    @IBOutlet weak var imageView: ImageView!
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var titleLabel: UILabel!
    
    override func setup(entry: AnyObject!) {
        if let broadcast = entry as? LiveBroadcast {
            nameLabel.text = "\(broadcast.broadcaster?.name ?? "") \("is_live_streaming".ls)"
            titleLabel.text = broadcast.title
            imageView.url = broadcast.broadcaster?.avatar?.small
        }
    }
}

@objc protocol MediaViewControllerDelegate: WLWrapEmbeddedViewControllerDelegate {

optional func mediaViewControllerDidAddPhoto(controller: MediaViewController)

optional func mediaViewControllerDidOpenLiveBroadcast(controller: MediaViewController)

}

class MediaViewController: WLWrapEmbeddedViewController {
    
    var dataSource: MediaDataSource!
    @IBOutlet  weak var streamView: StreamView!
    @IBOutlet var primaryConstraint: LayoutPrioritizer!
    @IBOutlet weak var uploadingView: WLUploadingView!
    @IBOutlet weak var addPhotoButton: UIButton!
    
    var history: History!
    
    weak var candyMetrics: StreamMetrics!
    @IBOutlet weak var scrollDirectionPrioritizer: LayoutPrioritizer!

    override func viewDidLoad() {
        super.viewDidLoad()
        
        guard let wrap = wrap else {
            return
        }
        
        let streamView = self.streamView
        streamView.contentInset = streamView.scrollIndicatorInsets
        
        dataSource = MediaDataSource(streamView: streamView)
        dataSource.scrollDirectionLayoutPrioritizer = self.scrollDirectionPrioritizer
        dataSource.numberOfGridColumns = 3;
        dataSource.layoutSpacing = Constants.pixelSize
        dataSource.autogeneratedPlaceholderMetrics.identifier = "WLWrapPlaceholderViewHistory"
        
        if wrap.requiresFollowing && WLNetwork.sharedNetwork().reachable {
            wrap.candies = nil
        }
        
        dataSource.liveBroadcasts = { [weak wrap] _ -> [LiveBroadcast]? in
            return wrap?.liveBroadcasts
        }
        let loader = IndexedStreamLoader(identifier: "MediaViews", index: 0)
        dataSource.liveBroadcastMetrics.loader = loader
        dataSource.liveBroadcastMetrics.selection = { [weak self] (item, broadcast) -> Void in
            if !WLNetwork.sharedNetwork().reachable {
                WLToast.showWithMessage("no_internet_connection".ls)
                return;
            }
            if let controller = self?.storyboard?["liveBroadcast"] as? LiveBroadcastViewController {
                controller.wrap = self?.wrap
                controller.broadcast = broadcast as? LiveBroadcast
                self?.navigationController?.presentViewController(controller, animated: false, completion: nil)
            }
        }
        dataSource.addMetrics(StreamMetrics(loader: loader.loader(1))).size = 42
        
        candyMetrics = dataSource.addMetrics(StreamMetrics(loader: loader.loader(2)))
        candyMetrics.size = view.width / 2.5
        candyMetrics.selectable = false
        candyMetrics.selection = { [weak self] (item, candy) -> Void in
            guard let cell = item?.view as? CandyCell, let candy = candy as? Candy else {
                return
            }
            if candy.valid && cell.imageView.image != nil {
                if let historyViewController = candy.viewController() as? WLHistoryViewController {
                    historyViewController.history = self?.history
                    let presentingImageView = WLPresentingImageView.sharedPresenting()
                    presentingImageView.delegate = self
                    historyViewController.presentingImageView = presentingImageView
                    presentingImageView.presentCandy(candy, fromView: cell, success: { (_) -> Void in
                        self?.navigationController?.pushViewController(historyViewController, animated: false)
                        }, failure: { (_) -> Void in
                            ChronologicalEntryPresenter.presentEntry(candy, animated: true)
                    })
                }
            } else {
                ChronologicalEntryPresenter.presentEntry(candy, animated: true)
            }
        }
        
        dataSource.appendableBlock = { [weak self] (dataSource) -> Bool in
            return self?.wrap?.uploaded ?? false
        }
        
        history = History(wrap: wrap)
        
        dataSource.setRefreshableWithStyle(.Orange)
        
        firstLoadRequest()
        
        uploadingView.queue = WLUploadingQueue.defaultQueueForEntityName(Candy.entityName())
        
        WLNetwork.sharedNetwork().addReceiver(self)
        
        if wrap.candies?.count > 0 {
            dropDownCollectionView()
        }
        Wrap.notifier().addReceiver(self)
    }
    
    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)
        guard let wrap = wrap where wrap.valid else {
            run_after(0.5, { () -> Void in
                self.navigationController?.popViewControllerAnimated(false)
            })
            return
        }
        
        if let candies = wrap.candies as? Set<Candy> {
            for candy in candies where candy.valid && candy.unread {
                candy.unread = false
            }
        }
        RecentUpdateList.sharedList.refreshCount({ [weak self] (_) -> Void in
            self?.badge?.value = RecentUpdateList.sharedList.unreadCandiesCountForWrap(wrap)
            }) { (_) -> Void in
        }
        dataSource.items = history
        uploadingView.update()
        streamView.unlock()
    }
    
    override func viewWillDisappear(animated: Bool) {
        super.viewWillDisappear(animated)
        streamView.lock()
    }

    private func firstLoadRequest() {
        if wrap?.candies?.count > 0 {
            dataSource.paginatedSet?.newer(nil, failure: nil)
        }
    }
    
    private func dropDownCollectionView() {
        primaryConstraint.defaultState = false
        UIView.animateWithDuration(1, delay: 0.2, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.3, options: [], animations: { () -> Void in
            self.primaryConstraint.defaultState = true
            }, completion: nil)
    }
    
    @IBAction func addPhoto(sender: UIButton) {
        guard let wrap = wrap else {
            return
        }
        WLFollowingViewController.followWrapIfNeeded(wrap) { [weak self] () -> Void in
            if let controller = self {
                (controller.delegate as? MediaViewControllerDelegate)?.mediaViewControllerDidAddPhoto?(controller)
            }
        }
    }
    
    @IBAction func liveBroadcast(sender: UIButton) {
        if !WLNetwork.sharedNetwork().reachable {
            WLToast.showWithMessage("no_internet_connection".ls)
            return;
        }
        guard let wrap = wrap else {
            return
        }
        WLFollowingViewController.followWrapIfNeeded(wrap) { [weak self] () -> Void in
            if let controller = self {
                (controller.delegate as? MediaViewControllerDelegate)?.mediaViewControllerDidOpenLiveBroadcast?(controller)
            }
        }
    }
}

extension MediaViewController: WLPresentingImageViewDelegate {
    
    func presentingImageView(presentingImageView: WLPresentingImageView!, dismissingViewForCandy candy: Candy!) -> UIView! {
        if let item = streamView.itemPassingTest({ (($0.entry as? HistoryItem)?.candies.contains(candy) ?? false) && $0.metrics == self.candyMetrics}) {
            streamView.scrollRectToVisible(item.frame, animated: true)
            if let cell = item.view as? HistoryItemCell {
                if let item = cell.streamView.itemPassingTest({ ($0.entry as? Candy) == candy}) {
                    cell.streamView.scrollRectToVisible(item.frame, animated: true)
                    return item.view
                } else {
                    return nil
                }
            } else {
                return nil
            }
        } else {
            return nil
        }
    }
}

extension MediaViewController: WLNetworkReceiver {
    
    func networkDidChangeReachability(network: WLNetwork!) {
        dataSource.reload()
    }
}

extension MediaViewController: EntryNotifying {
    
    func notifier(notifier: EntryNotifier, didUpdateEntry entry: Entry, event: EntryUpdateEvent) {
        if (event == .LiveBroadcastsChanged) {
            dataSource.reload()
        }
    }
    
    func notifier(notifier: EntryNotifier, shouldNotifyOnEntry entry: Entry) -> Bool {
        return wrap == entry
    }
}
